<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Diana Qing</h2>

<br><br>

<div>
<p>Webpage: https://cal-cs184-student.github.io/hw-webpages-sp24-diana-qing/hw2/index.html</p>
<h2 align="middle">Overview</h2>
<p>
    In this homework, I used de Casteljau's algorithm to create Bezier curves and surfaces given a set of control points. I also used the half-edge data structure to traverse triangle meshes, which allowed me
	to (1) achieve flat and Phong shading for smooth surfaces and (2) implement edge flips and splits to ultimately upsample meshes using loop subdivision. Something interesting I learned from completing this assignment
	is how subdivision may not be symmetrical depending on what edges exist in the starting .dae file, but this asymmetry can potentially be addressed through splitting and flipping some edges before beginning subdivision.
	
	When creating Bezier curves, it was also interesting seeing how changing the location of one control point only affects the curve between this control point and the other points it's directly connected to, but doesn't
	affect the curves among the other control points.
</p> 
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


<b>
  Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
</b>
<p>
    Given n original control points, de Casteljau's algorithm allows us to create a smooth Bezier curve that connects the leftmost and rightmost original control points. From the 
	
	allows us to obtain a new set of n-1 control points
	from the
</p>
<br>


<b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b>
<p>
    I created a new .bzc file, curve3.bzc, containing 6 control points:
</p>
<!-- Example of including a single figure -->
<div align="middle">
  <img src="images/q1/step1.png" align="middle" width="50%">
  <figcaption>6 control points in curve3.bzc</figcaption>
</div>
<br>

<b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b>
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/q1/step2.png" align="middle" width="500px"/>
        <figcaption>Level 0</figcaption>
      </td>
      <td>
        <img src="images/q1/step3.png" align="middle" width="500px"/>
        <figcaption>Level 1</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/q1/step4.png" align="middle" width="500px"/>
        <figcaption>Level 2</figcaption>
      </td>
      <td>
        <img src="images/q1/step5.png" align="middle" width="500px"/>
        <figcaption>Level 3</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/q1/step6.png" align="middle" width="500px"/>
        <figcaption>Level 4</figcaption>
      </td>
	  <td>
        <img src="images/q1/final.png" align="middle" width="500px"/>
        <figcaption>Final Bezier curve</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b>
<p>
    Using curve3.bzc, I obtained a slightly different Bezier curve by manually moving around some of the original control points and modifying t through mouse scrolling.
</p>  
<div align="middle">
	<img src="images/q1/final_modified.png" align="middle" width="60%">
	<figcaption>Slightly different Bezier curve</figcaption>
</div>
<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<b>
  Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b>
<div align="middle">
	<img src="images/q2/teapot_closer_up.png" align="middle" width="90%">
	<figcaption>bez/teapot.bez</figcaption>
</div>
<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<b>
  Briefly explain how you implemented the area-weighted vertex normals.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b>
<div align="middle">
	<img src="images/q3/teapot.png" align="middle" width="80%">
	<figcaption>teapot.dae (default flat shading)</figcaption>
</div>

<div align="middle">
	<img src="images/q3/teapot_smooth.png" align="middle" width="80%">
	<figcaption>teapot.dae (Phong shading)</figcaption>
</div>
<br>


<h3 align="middle">Part 4: Edge Flip</h3>
<b>
  Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    I implemented edge flips by closely following the instructions in the spec and drawing a detailed diagram labeling each mesh element 
	(vertex, edge, face, and half-edge) before and after flipping, which allowed me to keep track of exactly what updates needed to be made
	to each mesh element.
</p>
<br>
<div align="middle">
	<img src="images/q4/edge_flip_diagram.png" align="middle" width="85%">
	<figcaption>Diagram labeling mesh elements before and after edge flip</figcaption>
</div>
<br>

<b>
  Show screenshots of the teapot before and after some edge flips.
</b>
<div align="middle">
	<table style="width:100%">
	  <tr align="center">
		<td>
		  <img src="images/q4/teapot_orig.png" align="middle" width="600px"/>
		  <figcaption>Teapot (with default flat shading) before edge flips</figcaption>
		</td>
		<td>
		  <img src="images/q4/teapot_with_flips.png" align="middle" width="600px"/>
		  <figcaption>Teapot (with default flat shading) after edge flips</figcaption>
		</td>
	  </tr>
	  <br>
	  <tr align="center">
		<td>
		  <img src="images/q4/teapot_smoothed_orig.png" align="middle" width="600px"/>
		  <figcaption>Teapot (with Phong shading) before edge flips</figcaption>
		</td>
		<td>
		  <img src="images/q4/teapot_smoothed_with_flips.png" align="middle" width="600px"/>
		  <figcaption>Teapot (with Phong shading) after edge flips</figcaption>
		</td>
	  </tr>
	  <br>
	</table>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    Fortunately, I didn't experience an eventful debugging journey since I was able to get my edge flipping to work by following the 
	guidelines in the spec and drawing a detailed diagram labeling each mesh element (vertex, edge, face, and half-edge) before and after 
	flipping so I knew exactly what updates had to made to each mesh element.
</p>
<br>


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    Similar to Part 4, I implemented edge splits by closely following the instructions in the spec and drawing a detailed diagram where I labeled 
	every mesh element (vertex, edge, face, and half-edge) that exists before and after splitting, which allowed me to keep track of exactly what
	updates need to be made to each mesh element along with what new elements I need to create. In doing so, I found that I had to create 1 new vertex,
	3 new edges, 2 new faces, and 6 new half-edges.
</p>
<br>
<div align="middle">
	<img src="images/q5/edge_split_diagram.png" align="middle" width="90%">
	<figcaption>Diagram labeling mesh elements before and after edge split</figcaption>
</div>
<br>

<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>
<p>
    Here are screenshots of teapot.dae before and after some edge splits:
</p>
<div align="middle">
	<table style="width:100%">
	  <tr align="center">
		<td>
		  <img src="images/q5/teapot_before_splits.png" align="middle" width="600px"/>
		  <figcaption>Teapot before edge splits</figcaption>
		</td>
		<td>
		  <img src="images/q5/teapot_after_splits.png" align="middle" width="600px"/>
		  <figcaption>Teapot after edge splits</figcaption>
		</td>
	  </tr>
	  <br>
	</table>
</div>
<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>
<p>
    Here are screenshots of teapot.dae before any edge splits and flips, after some edge splits (but no edge flips), and after both edge splits and flips:
</p>
<div align="middle">
	<img src="images/q5/teapot_no_splits_no_flips.png" align="middle" width="800px"/>
	<figcaption>Teapot before edge splits and flips</figcaption>
</div>

<div align="middle">
	<img src="images/q5/teapot_with_splits.png" align="middle" width="800px"/>
	<figcaption>Teapot after edge splits (but no edge flips)</figcaption>
</div>

<div align="middle">
	<img src="images/q5/teapot_with_splits_and_flips.png" align="middle" width="800px"/>
	<figcaption>Teapot after both edge splits and edge flips</figcaption>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    Similar to Part 4, I didn't experience an eventful debugging journey as I was able to get my edge splits working 
	by closely following the instructions in the spec and drawing a detailed diagram showing what mesh elements exist 
	before and after splitting, which allowed me to easily see how each mesh element should be updated and what new 
	mesh elements I had to create.
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>
<p>
	I split boundary edges similarly to how I split non-boundary edges. I drew a diagram labeling every mesh element that exists before and after 
	splitting, allowing me to see how each element should be updated after splitting and what new elements needed to be created. Instead of turning 2
	faces into 4 faces, when splitting boundary edges, we just turn 1 face into 2 faces. Thus, the new elements created from splitting a boundary are: 
	1 new vertex (m), 2 new edges (am and mc), 1 new face (triangle amc), and 4 new half-edges (h6, h7, h8, h9).
</p>
<div align="middle">
	<img src="images/q5/ec/boundary_edge_split_diagram.png" align="middle" width="90%">
	<figcaption>Diagram labeling mesh elements before and after splitting a boundary edge</figcaption>
</div>
<p>
	Before splitting, for the half-edges associated with the boundary edge (h0 and h1), it's also important to indicate which edge is inside the 
	triangle face versus which is in the boundary face. For the edge e0 passed into the splitEdge function, I check if e0->halfedge is in the boundary. 
	If it's not, I set halfedge h0 to be e0->halfedge->twin since I always want h0 to be the halfedge associated with the boundary edge that's in the 
	boundary as that's how it's labeled in my diagram. Then I can set all the other mesh elements based on h0.

	Below are images of beetle.dae before any boundary edge splits and after splitting some boundary edges (and also some non-boundary edges to ensure that
	splitting both boundary and non-boundary edges work). 
</p>
<br>
<div align="middle">
	<table style="width:100%">
	  <tr align="center">
		<td>
		  <img src="images/q5/ec/beetle_orig.png" align="middle" width="600px"/>
		  <figcaption>Beetle before boundary edge splits</figcaption>
		</td>
		<td>
		  <img src="images/q5/ec/beetle_with_boundary_edge_splits.png" align="middle" width="600px"/>
		  <figcaption>Beetle after splitting some boundary edges (and some non-boundary edge splits). The boundary edges I split are the edges at the bottom of the front of car.</figcaption>
		</td>
	  </tr>
	  <br>
	</table>
</div>
<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<!-- Loop subdivision of cube without pre-splits -->
<p>
    Below are the results of loop subdivision on cube.dae without pre-splitting any edges:
</p>
<div align="middle">
	<table style="width:100%">
	  <tr align="center">
		<td>
		  <img src="images/q6/no_presplit/start.png" align="middle" width="500px"/>
		  <figcaption>cube.dae with no loop subdivision</figcaption>
		</td>
		<td>
		  <img src="images/q6/no_presplit/1loop.png" align="middle" width="500px"/>
		  <figcaption>1 loop subdivision</figcaption>
		</td>
	  </tr>
	  <br>
	  <tr align="center">
		<td>
		  <img src="images/q6/no_presplit/2loops.png" align="middle" width="500px"/>
		  <figcaption>2 loop subdivisions</figcaption>
		</td>
		<td>
		  <img src="images/q6/no_presplit/3loops.png" align="middle" width="500px"/>
		  <figcaption>3 loop subdivision</figcaption>
		</td>
	  </tr>
	  <br>
	  <tr align="center">
		<td>
		  <img src="images/q6/no_presplit/4loops.png" align="middle" width="500px"/>
		  <figcaption>4 loop subdivisions</figcaption>
		</td>
		<td>
		  <img src="images/q6/no_presplit/5loops.png" align="middle" width="500px"/>
		  <figcaption>5 loop subdivisions</figcaption>
		</td>
	  </tr>
	  <br>
	</table>
</div>
<br>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>
<p>
    Below are results of splitting some edges in cube.dae before beginning loop subdivision. Pre-processing by pre-splitting some edges makes the cube subdivide more symmetrically because 
</p>
<!-- Loop subdivision of cube with pre-splits -->
<div align="middle">
	<table style="width:100%">
	  <tr align="center">
		<td>
		  <img src="images/q6/presplit_option2/start.png" align="middle" width="500px"/>
		  <figcaption>cube.dae with no splits and no loop subdivisions</figcaption>
		</td>
		<td>
		  <img src="images/q6/presplit_option2/1split.png" align="middle" width="500px"/>
		  <figcaption>cube.dae with 1 edge split but no loop subdivisions </figcaption>
		</td>
	  </tr>
	  <br>
	  <tr align="center">
		<td>
		  <img src="images/q6/presplit_option2/2splits.png" align="middle" width="500px"/>
		  <figcaption>cube.dae with more edge splits but no loop subdivisions</figcaption>
		</td>
		<td>
		  <img src="images/q6/presplit_option2/1loop.png" align="middle" width="500px"/>
		  <figcaption>1 loop subdivision</figcaption>
		</td>
	  </tr>
	  <br>
	  <tr align="center">
		<td>
		  <img src="images/q6/presplit_option2/2loops.png" align="middle" width="500px"/>
		  <figcaption>2 loop subdivisions</figcaption>
		</td>
		<td>
		  <img src="images/q6/presplit_option2/3loops.png" align="middle" width="500px"/>
		  <figcaption>3 loop subdivisions</figcaption>
		</td>
	  </tr>
	  <br>
	  <tr align="center">
		<td>
		  <img src="images/q6/presplit_option2/4loops.png" align="middle" width="500px"/>
		  <figcaption>4 loop subdivisions</figcaption>
		</td>
	  </tr>
	</table>
</div>
<br>


<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
<b>
    Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh in your write-up.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Include a series of screenshots showing your original mesh and your mesh after one and two rounds of subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as well.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


</body>
</html>